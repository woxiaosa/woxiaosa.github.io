<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://woxiaosa.github.io/</id>
    <title>Gridea</title>
    <updated>2021-11-06T08:51:50.474Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://woxiaosa.github.io/"/>
    <link rel="self" href="https://woxiaosa.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://woxiaosa.github.io/images/avatar.png</logo>
    <icon>https://woxiaosa.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[锁、条件变量、信号量]]></title>
        <id>https://woxiaosa.github.io/post/suo-tiao-jian-bian-liang-xin-hao-liang/</id>
        <link href="https://woxiaosa.github.io/post/suo-tiao-jian-bian-liang-xin-hao-liang/">
        </link>
        <updated>2021-11-06T07:59:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>在多线程环境下，线程、进程之间需要进行同步，以做到互斥的访问临界资源。</p>
<h3 id="锁">锁</h3>
<h3 id="条件变量">条件变量</h3>
<p>在生产者消费者问题中，如果剩余位置为0，生产者会陷入循环等待，在消费者释放空位之前，生产者的循环等待是无意义的，浪费了CPU资源。<strong>条件变量</strong>就是解决这一问题的，它提供了一套挂起/睡眠机制。</p>
<p>条件变量一般提供两个接口，<code>cond_wait</code>和<code>cond_signal</code>，分别用于挂起当前线程与唤醒等待在该条件变量上的线程。</p>
<p>下面的代码，展示了使用条件变量<code>condition_variable</code>解决生产者消费者问题。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
using namespace std;

int empty_slot = 5;
condition_variable empty_cond;
mutex empty_mutex;
int filled_slot = 0;
condition_variable filled_cond;
mutex filled_mutex;

void producer() {
    while (true) {
        // get a new item
        unique_lock&lt;mutex&gt; empty_guard(empty_mutex);
        while (empty_slot == 0) {
            empty_cond.wait(empty_guard);
        }
        empty_slot--;
        empty_guard.unlock();
        // add a item
        unique_lock&lt;mutex&gt; filled_guard(filled_mutex);
        filled_slot++;
        filled_cond.notify_one();
    }
}

void consumer() {
    while (true) {
        unique_lock&lt;mutex&gt; filled_guard(filled_mutex);
        while (filled_slot == 0) {
            filled_cond.wait(filled_guard);
        }
        filled_slot--;
        filled_guard.unlock();
        // consume a item
        unique_lock&lt;mutex&gt; empty_guard(empty_mutex);
        empty_slot++;
        empty_cond.notify_one();
    }
}

int main() {

    thread p(producer);
    thread c(consumer);
    p.join();
    c.join();
    return 0;
}
</code></pre>
<p>wait()函数在返回后，会再次进行检查条件是否满足（slot是否为0），这是为了防止出现<strong>虚假唤醒</strong>。signal可能会一次唤醒多个线程，如果一个线程最早处理，并对条件进行了修改，那么该线程如果继续往下执行，会引发不正确的情况出现。</p>
<p>一般来说，条件变量的结构体内维护了一个<code>wait_list</code>，记录等待在该条件变量上的线程。</p>
<p>当线程调用<code>cond_wait</code>时，会首先把线程加入到该条件变量的等待链表中，然后<strong>原子的</strong>挂起/释放锁。然后等待被<code>wakeup</code>，再次持有锁。如果第二步，不能保证原子化，那么会出现以下两种情况：</p>
<ul>
<li>先挂起：那么将无法把锁释放，也就不会被其他线程wakeup</li>
<li>先释放：在挂起前，如果有线程尝试signal，那么该线程再被唤醒时，出现错误</li>
</ul>
<h3 id="信号量">信号量</h3>
<p>信号量在不同线程之间充当信号灯，根据资源的剩余数量，控制线程执行或等待。信号量一般有两个操作，<code>wait</code>和<code>signal</code>。前者在资源数量小于等于0时，进入循环等待；后者会增加可用资源的数量。</p>
<p>当信号量的初值为1时，与互斥锁差别不大。另外，信号量一般是由条件变量、互斥锁、计数器实现的，可以这么说，信号量利用条件变量实现了更高级的抽象。</p>
<p>在C++标准库中，仅提供了<code>condition_variable</code>，没有提供信号量。利用信号量机制解决生产者、消费者问题的伪代码如下：</p>
<pre><code class="language-C">Semaphore filled_sem = 0;
Semaphore empty_sem = 5;

void producer() {
    while(True) {
        new_good = produce_good();
        wait(empty_sem);
        safe_add_good(new_good);
        signal(filled_sem);
    }
}

void consumer() {
    while(True) {
        wait(filled_sem);
        new_good = safe_get_good();
        signal(empty_sem);
        consume_good(new_good);
    }
}

</code></pre>
<p>尽管C++标准库没有提供信号量，但我们可以基于其原理实现一个信号量出来。下图是信号量实现的伪代码。</p>
<figure data-type="image" tabindex="1"><img src="https://woxiaosa.github.io//post-images/1636187988498.png" alt="" loading="lazy"></figure>
<pre><code class="language-C++">class Semaphore {
private:
  size_t avail;
  std::mutex m;
  std::condition_variable cv;

public:
  // only one thread can call this; by default, we construct a binary semaphore
  explicit Semaphore(int avail_ = 1) : avail(avail_) {}

  void wait() {
    std::unique_lock&lt;std::mutex&gt; lk(m);
    cv.wait(lk, [this] { return avail &gt; 0; });
    avail--;
  }

  void signal() {
    std::unique_lock&lt;std::mutex&gt; lk(m);
    avail++;
    cv.notify_one();
  }

  size_t available() const {
    return avail;
  }
};
</code></pre>
<p>可以注意到，<code>wait()</code>函数中，没有使用<code>while()</code>循环检查条件是否成立，这是因为我们向<code>cv.wait</code>传入了一个lambda函数，<code>cv.wait</code>的函数签名为：</p>
<pre><code class="language-C++">template&lt; class Predicate &gt; 
void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred );
</code></pre>
<p>内部是这样调用<code>pred</code>函数的：</p>
<pre><code class="language-C++">while (!pred()) {
    wait(lock);
}
</code></pre>
<h3 id="相关问题">相关问题</h3>
<h4 id="有了互斥锁为什么要需要条件变量">有了互斥锁，为什么要需要条件变量</h4>
<p>互斥锁与条件变量不是解决同一个问题的。</p>
<p>互斥锁用于解决临界区问题，保证互斥的访问临界资源；而条件变量通过挂起/唤醒机制来避免循环等待，节省CPU资源，另外条件变量的实现需要用到互斥锁。</p>
<p>所以说，这二者所解决的问题是不一样的。</p>
<h3 id="参考">参考</h3>
<p>现代操作系统：原理与实现<br>
https://zhu45.org/posts/2019/Oct/20/semaphore/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现代金融业务复习]]></title>
        <id>https://woxiaosa.github.io/post/xian-dai-jin-rong-ye-wu-fu-xi/</id>
        <link href="https://woxiaosa.github.io/post/xian-dai-jin-rong-ye-wu-fu-xi/">
        </link>
        <updated>2021-11-04T09:10:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="股票">股票</h3>
<h4 id="评价标准">评价标准</h4>
<ul>
<li>PE市盈率：股价/每股盈利</li>
<li>EPS每股盈余：利润/流通在外的股数</li>
</ul>
<h4 id="定义及分类">定义及分类</h4>
<p>股票是公司发行的公司所有权凭证，股票有多种分类方式，分类方式1：</p>
<ul>
<li>Preferred Stock（优先股）</li>
</ul>
<p>Described as equity ownership of a corporation’s shares where the owners are entitled to regular fixed dividend before a dividend can be paid to common stock holders.</p>
<p>与普通股相比，优先获得固定收益</p>
<ul>
<li>Common Stock（普通股）</li>
</ul>
<p>Security representing (partial) ownership of a company’s assets, generally with the right to participate in dividends and in most cases to vote on major matters affecting stockholder interests.</p>
<p>享有公司资产的部分所有权，通常有一定的投票权以及分红权。</p>
<ul>
<li>Convertible bond（可转债）</li>
</ul>
<p>一种债券，债券持有人，可以按照约定的价格，将债券转为公司普通股。</p>
<p>分类方式2：</p>
<ul>
<li>Class A Stock</li>
</ul>
<p>It is the stock issued for public trading from an IPO or if a company issues new stock at a later date.</p>
<p>IPO中发行的股票，或者后续发行的股票</p>
<ul>
<li>Class B Stock</li>
</ul>
<p>It is a special category of stock usually retained by company founders at the time a company goes public. It carries certain rights not granted to stock available to the public. One of those rights is one share of Class B stock has 10 votes while regular shares have only one vote.</p>
<p>特殊类型的股票，通常由公司创始人在公司上市时保留。投票权较A类股票更多。</p>
<h4 id="stock-markets-type">Stock Markets Type</h4>
<ul>
<li>Primary Market(IPO)（一级市场）</li>
</ul>
<p>Initial Public Offering(IPO) 首次向公众售卖公司股票，primary market就是首次向公众售卖股票时形成的市场。</p>
<ul>
<li>Secondary Market</li>
</ul>
<p>the financial market for trading of securities that have already been issued in an initial private or public offering.</p>
<ul>
<li>OTC Market（场外交易市场）</li>
</ul>
<p>a financial market where products are traded over-the-counter</p>
<h4 id="stock-trade-flow">Stock Trade Flow</h4>
<h4 id="order-type">Order Type</h4>
<p><strong>Limit Risks</strong></p>
<ul>
<li>Basket：A group of individual orders that are saved in a single file and submitted as a package which diversify the risks.（多买几个共担风险）</li>
<li>Stop：A Stop order becomes a market order to buy or sell securities or commodities once the specified stop price is attained or penetrated.（always below the current market price，用于止损）</li>
<li>Stop Limit：A Stop Limit order becomes a limit order once the specified stop price is attained or penetrated.（只有达到stop price时，才变为limit order）</li>
</ul>
<p><strong>Speed of Execution</strong></p>
<ul>
<li>Market：an order to buy or sell an asset at the bid or offer price currently available in the marketplace.（在市场上当前可用的出价卖掉，有点像随缘卖？）</li>
<li>Market If Touched：An MIT (market-if-touched) is an order to buy (or sell) an asset below (or above) the market. This order is held in the system until the trigger price is touched, and is then submitted as a market order. An MIT order is similar to a stop order, except that an <strong>MIT sell order is placed above the current market price</strong>, and a stop sell order is placed below.（与Stop order相反，卖出时高于市价，买进时低于市价）</li>
<li>Market On Open：A market order executed at the market's open at the market price（开盘就交易）</li>
<li>A market order executed at the market's close at the market price（收盘就交易）.</li>
<li>Pegged to Market：An order that is pegged to buy on the best offer and sell on the best bid.（按最好的出价交易）</li>
</ul>
<p><strong>Price Improvement</strong></p>
<ul>
<li>Limit：an order to buy or sell a contract at a specified price or better</li>
<li>Limit If Touched：达到价格后，变为limit订单</li>
</ul>
<p><strong>Discretion</strong></p>
<ul>
<li>Discretionary：规定一个limit价格，然后可以自由交易</li>
<li>Hidden：大订单、其他人看不到</li>
<li>Iceberg：大订单，但可以显示出部分数量</li>
</ul>
<p><strong>Market Timing</strong></p>
<ul>
<li>All or None：只能一次性成交</li>
<li>Fill or Kill：必须在规定时间内完成交易</li>
<li>GTD：good-till-date在某个日子之前都有效</li>
<li>GTC：订单直到完成或取消</li>
<li>IOC：immediate or canceled，一旦执行，剩余的就取消</li>
</ul>
<h3 id="foreign-exchange-market">Foreign Exchange Market</h3>
<h4 id="资本货币外汇市场特征">资本/货币/外汇市场特征</h4>
<ul>
<li>资本市场：由股票、债券市场组成，长期资金市场，风险大，参与者有机构和个人，流动性差，收益高，解决长期资金困难</li>
<li>货币市场：短期资金市场，融资期限在一年以下，流动性强，风险小，参与者主要是机构，收益稳定</li>
<li>外汇市场：一国货币与另一国货币的交换市场
<ul>
<li>汇率对多种因素高度敏感</li>
<li>全天候24h</li>
<li>持续报价</li>
<li>经济宏观预期会影响汇率</li>
<li>美元兑日元、欧元兑美元等成对交易</li>
<li>以美元为中心</li>
</ul>
</li>
</ul>
<h4 id="原生品衍生品">原生品/衍生品</h4>
<ul>
<li>原生品：货币、外汇、债务性金融商品和所有权性金融商品等金融资产，以及这些金融资产价格的总称,衍生品所依据的金融资产</li>
<li>衍生品：一种金融合同，价值取决于另一实体的表现</li>
</ul>
<p>衍生品诞生的目的：对冲风险，抵消投资过程中伴随的潜在风险和收益</p>
<h3 id="bondfixed-income">Bond(Fixed Income)</h3>
<h4 id="yield-of-bonds">Yield of Bonds</h4>
<ul>
<li>Current Yield当前收益率：债券的当前收益率是等于债券的年利息与债券当前市场价格之比。</li>
<li></li>
</ul>
<p>如果你花95.92￥买了一个价值100￥的债券，票面利率为5%，那么你的当前收益率为：<br>
0.05 * 100 / 95.92 = 5.21%</p>
<ul>
<li>Yield to Maturity到期收益率<br>
到期收益率=(收回金额-购买价格+总利息)/（购买价格×总期数）×100%</li>
</ul>
<h4 id="prices-of-bonds">Prices of Bonds</h4>
<ul>
<li>Use YTM</li>
<li>Use Spot Rate</li>
</ul>
<h4 id="relationship-between-price-and-yield">relationship between price and yield</h4>
<p>反比关系</p>
<h3 id="mutul-fund-基金">Mutul Fund 基金</h3>
<p>基金是指一种利益共享、风险共担的集合证券投资方式。通过发行基金单位，集中投资者的资金，由托管人托管，由基金管理人管理和运用资金，从事股票、债券等金融工具投资，并将投资收益按基金投资者的投资比例进行分配</p>
<h4 id="基金收益">基金收益</h4>
<p>基金净值=总净资产/基金份额</p>
<h4 id="基金的好处">基金的好处</h4>
<ul>
<li>专业化管理<br>
共同基金公司聘有专业基金经理人及研究团队从事市场研究，只要花少许的基金管理费就可享受到专家的服务，可以说是小额投资人的最佳福音。</li>
<li>成本低<br>
规模大，所以成本低</li>
<li>分散投资风险<br>
共同基金的资产较一般投资人来得庞大，故足以将资金分散於不同的股票、甚至不同的投资工具中，以达到真正的风险分散，而不致因一支错误的选股而产生重大的亏损</li>
<li>流动性强</li>
<li>便捷性</li>
<li>安全性：监管到位</li>
</ul>
<h4 id="基金公司结构">基金公司结构</h4>
<ul>
<li>Front Office：sale/Client， generate Revenue</li>
<li>Middle Office：Bridge between front and back office</li>
<li>Back Office：Trade/Sales support， Do not generate revenue</li>
</ul>
<h4 id="货币时间价值">货币时间价值</h4>
<p>由于潜在的赚钱能力，现在可用的钱比将来同样的钱更值钱。金融的这一核心原则认为，只要钱能赚取利息，那么越早收到的钱就越值钱。</p>
<ul>
<li>终值Future Value（FV）：在未来某一特定日期对资产或现金进行估价。</li>
<li>现值Present Value（PV）：未来一笔钱的当前价值</li>
<li>现金流Cash</li>
</ul>
<pre><code>EAR = ( 1 + periodic rate)^m – 1=(1+1%)^12-1
Periodic rate(期间利率) = nominal rate/m（名义利率）
M= the number of compounding periods per year（一年内复利周期的数目）
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://woxiaosa.github.io//post-images/1636114563421.png" alt="" loading="lazy"></figure>
<h4 id="基金分类">基金分类</h4>
<p>按规模是否固定来分：</p>
<ul>
<li>封闭式基金</li>
<li>开放式基金</li>
</ul>
<p>不同点：</p>
<ul>
<li>存续期限不同</li>
<li>规模可变性不同</li>
<li>交易方式不同</li>
<li>可赎回性不同</li>
</ul>
<p>按照组织形式分类：</p>
<ul>
<li>公司型基金</li>
<li>契约型基金</li>
</ul>
<p>国别分类：</p>
<ul>
<li>在按基金：本国募集基金，投资本国证券市场</li>
<li>离岸基金：在他国发行证券基金单位，但投资第三国QDII</li>
</ul>
<p>流通方式：</p>
<ul>
<li>公募基金：公开募集基金</li>
<li>私募基金：不公开募集基金</li>
</ul>
<p>按投资证券类型分为：</p>
<ul>
<li>股票型基金</li>
<li>债券基金</li>
<li>货币基金</li>
<li>混合型基金（股票+债券）</li>
<li>衍生品投资基金</li>
<li>FOF（基金的基金）</li>
</ul>
<p>按投资风格：</p>
<ul>
<li>成长型基金</li>
<li>收入型基金</li>
<li>平衡型基金</li>
</ul>
<p>ETF：交易型开放式指数基金，集成了开放式与封闭式基金的有点，投资者既可以在二级市场买卖ETF份额，也可以向基金公司申购或赎回ETF份额<br>
LOF：上市开放式基金，投资者既可以在指定网点申购与赎回基金份额，也可以在交易所买卖该基金</p>
<h4 id="72定律">72定律</h4>
<p>给定收益<code>i</code>和本金，问何时翻倍（成为2倍），ans = 7 / i<br>
例如，i=12%，7%12%= 6 yeas</p>
<h4 id="投资回报计算">投资回报计算</h4>
<ul>
<li>Money weighted return（资本加权回报率）</li>
</ul>
<p>考虑了所有现金流入和流出的投资组合的内部回报率。</p>
<ul>
<li>Time weighted return（时间加权回报率）(评估业绩的最佳方法)</li>
</ul>
<p>复合增长率</p>
<p>例题：t=0，花100购买一股，在t=1的末尾，花120购买一股，在t=2的末尾，以每股130的价格卖出，在每年年底的持有期内，该股票支付每股2美元的股息。请计算资本加权回报率和时间加权回报率。<br>
<img src="https://woxiaosa.github.io//post-images/1636033655156.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>资本加权回报率<br>
首先确定每个流入和流出的时间：<br>
t = 0: 购买股票-100<br>
t = 1: 获得第一支股的股息(dividend) + 2<br>
: 购买股票-120<br>
总共, t= 1, -118<br>
t = 2: 获得股息+4<br>
卖出股票得到+260<br>
总共, t= 2 +264<br>
其次，PVoutFlows = PVinflows<br>
100 + 118 / (1 + r) = 264/(1+r)^2<br>
r = 13.86%</p>
</li>
<li>
<p>时间加权回报率<br>
首先，将收益划分到两个子阶段<br>
阶段一：开始价格100，分红2，结束价格120<br>
阶段二：开始价格240（两只股），分红4，结束价格260<br>
然后，计算每个阶段的收益率<br>
HPR1 =<code>(120 + 2) / 100 - 1 = 22%</code><br>
HPR2 =<code>(260 + 4) / 240 - 1 = 10%</code><br>
最后，找出2年期间的复合年利率。<br>
(1 + r) ^2 = (1+22%)*(1+10%)<br>
r = 15.84%</p>
</li>
</ul>
<h4 id="主动型基金被动性基金">主动型基金/被动性基金</h4>
<ul>
<li>
<p>被动型基金：一般选取特定的指数成份股作为投资的对象，不主动寻求超越市场的表现，而是试图复制指数的表现</p>
</li>
<li>
<p>主动型基金：寻求取得超越市场的业绩表现为目标的一种基金</p>
</li>
<li>
<p>主动投资：相信个人投资能力能够战胜市场，寻求超越市场的表现</p>
</li>
<li>
<p>被动投资：顺应市场，不追求超越市场的表现</p>
</li>
</ul>
<h4 id="募集资金说明书">募集资金说明书</h4>
<figure data-type="image" tabindex="2"><img src="https://woxiaosa.github.io//post-images/1636034848278.png" alt="" loading="lazy"></figure>
<ul>
<li>权证（share warrant）：权证是一种有价证券，投资者付出权利金购买后，有权利（而非义务）在某一特定期间（或特定时点）按约定价格向发行人购买或者出售标的证券。其中：发行人是指上市公司或证券公司等机构</li>
<li>期权（option）：一种金融衍生品，给予特定时间以特定价格买入/卖出标的物的权利</li>
</ul>
<p>区别：</p>
<ul>
<li>期权没有发行人，且供给量基本不受限制，标准化合约</li>
<li>权证通常由上市公司发行，以资产作为担保，权证发行量是有限的，非标准化合约</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[访问某个域名的全过程]]></title>
        <id>https://woxiaosa.github.io/post/fang-wen-mou-ge-yu-ming-de-quan-guo-cheng/</id>
        <link href="https://woxiaosa.github.io/post/fang-wen-mou-ge-yu-ming-de-quan-guo-cheng/">
        </link>
        <updated>2021-11-03T14:46:30.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>查找浏览器缓存，一般浏览器会缓存DNS记录一段时间，如果在缓存中找到了该URL对应的IP，则直接返回IP</li>
<li>利用系统调用查找IP，OS在hosts文件中，有时会保存有URL与IP的对应，如果找到了则直接返回IP</li>
<li>路由器中，一般也会保存有DNS缓存，所以也会在路由器的缓存中进行查找，若查找到对应IP，则直接返回。</li>
<li>如果以上步骤还找不到，那么需要使用DNS协议。向本地DNS服务器，发送一个查询报文，最终会返回一个报文，包含有该主机名对应的IP地址。一般来说，本地DNS服务器会以<strong>迭代查询</strong>、<strong>递归查询</strong>。</li>
</ol>
<ul>
<li>迭代查询：DNS服务器收到请求报文时，要么返回域名对应的IP地址，要么返回他认为可能知道该信息的DNS服务器的地址</li>
<li>递归查询：如果DNS服务器不知道被查询域名对应的IP地址，那么该DNS服务器将以DNS客户的身份，继续向其他DNS服务器发送请求报文。<br>
<img src="https://woxiaosa.github.io//post-images/1635953671198.png" alt="" loading="lazy"></li>
</ul>
<ol start="5">
<li>得到IP地址后，应用层将所要传输的信息交付给传输层，HTTP请求报文格式一般如下：</li>
</ol>
<pre><code>// HTTP请求报文一般格式
GET /page.html HTTP/1.1
Host: www.****.com
Connection: close
User-agent: Mozilla/5.0
Accept-language: zh
</code></pre>
<ol start="6">
<li>传输层</li>
</ol>
<ul>
<li>如果此时本机没有与目标服务器建立连接，那么需要用三次握手来建立连接
<ul>
<li>首先随机选择一个序号<code>x</code>，向目标服务器发送一个SYN报文，并进入<code>SYN_SENT</code>状态</li>
<li>目标服务器收到SYN报文后，对该连接分配资源，将该连接放入到<code>半连接队列</code>，回复一个SYN ACK报文，确认号为<code>x + 1</code>，并随机选择一个序号<code>y</code>，并进入<code>SYN_RECV</code>状态</li>
<li>本机收到SYN ACK报文后，也对该连接分配资源，并回复ACK报文，确认号为<code>y+1</code>，序号为<code>x+1</code>，进入<code>ESTABLISH</code>状态</li>
<li>目标服务器收到ACK报文后，将该连接放入到<code>全连接</code>中，然后进入<code>ESTABLISH</code>状态，被<code>accept()</code>调用阻塞的线程将被唤醒，得到该连接对应套接字</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用<code>ss -t</code>可以查看本机连接的状态，能够看到不同端口两种队列的实际大小</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://woxiaosa.github.io//post-images/1635993129000.png" alt="" loading="lazy"></figure>
<ul>
<li>如果本机已与目标服务器建立连接，那么传输层需要在TCP首部，填入源端口号、目的端口号、序号、接收窗口、校验和等信息，然后将TCP报文段交付给网络层。<br>
<img src="https://woxiaosa.github.io//post-images/1635990058430.png" alt="" loading="lazy"></li>
</ul>
<p>传输层会将应用层传递的数据，放入到SKB中，如果发送队列中，有些SKB没有装满，那么会选择先将这部分SKB装满，然后再按照MSS，将数据划分成一个一个的分片，将其组织为sk_buff（<code>struct sk_buff</code>，是Linux中，用来对数据包进行封包、解包的结构体，sk_buff中包含了传输层、网络层、数据链路层的头部信息、载荷、以及其他元信息）。</p>
<p>在Linux-5.15的源码中，sk_buff部分定义如下：</p>
<pre><code class="language-C">struct sk_buff {
    ......
    __u16			    inner_transport_header;     // tcp/udp header
	__u16			    inner_network_header;       // ip/.. header
	__u16			    inner_mac_header; 
    unsigned int	len, data_len;
	__u16			    mac_len, hdr_len;
    .......
}
</code></pre>
<p>数据全部输入到发送队列或遇到某些错误（没有多余的SKB来存储数据了）后，就会尝试使用<code>tcp_push</code>发送数据。<code>tcp_push</code>会调用其他函数完成数据包的发送，这个过程，还涉及到了发送窗口、拥塞控制等流程的判断。</p>
<ol start="7">
<li>传输层调用网络层的某些方法后，会判断本机是否保存对应的路由项，如果没有，会丢弃该报文段。然后会在sk_buff中添加相关IP协议首部信息，包括协议版本、数据报长度、首部校验和等等。此外，会使用ARP协议，得到对应MAC地址。</li>
</ol>
<blockquote>
<p>如果不在同一个子网内，这个地方得到的MAC地址实际上是网关的MAC地址。例如，我使用<code>arp -a</code>查看本机arp缓存，网关ip为<code>10.82.23.1</code>，对应mac地址为<code>10-8c-cf-28-dc-80</code>，使用wireshark抓包，发现目的mac地址为<code>10-8c-cf-28-dc-80</code>。</p>
</blockquote>
<blockquote>
<p>在linux中，可以使用<code>route</code>命令查看路由表，路由表是由一个个的路由项组成的，可以由管理员手动设置，也可以由算法自动生成（动态路由）</p>
</blockquote>
<pre><code class="language-C">int __ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl,
		    __u8 tos) {
    ......
packet_routed:
    .....
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
    .......
	ip_copy_addrs(iph, fl4);
    ........
no_route:
	rcu_read_unlock();
	IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);
	kfree_skb(skb);
	return -EHOSTUNREACH;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://woxiaosa.github.io//post-images/1635990266079.png" alt="" loading="lazy"></figure>
<ol start="8">
<li>网络层会调用数据链路层的相关方法，发送数据包，该方法会调用网卡的驱动程序，让其将数据组装成帧，然后在物理链路上传输。驱动程序的工作流程，大致为，使用DMA将数据拷贝到网卡的发送队列，拷贝完成后，通知网卡发送数据，网卡发送好后，以终端的形式通知CPU，让其进行SKB等数据结构的清理。</li>
</ol>
<p>最终，会到达目标服务器，目标服务器会将需要返回的资源，放入到报文中，并添加必要的头部信息，按照响应的方式发送回来， 浏览器在接收到返回的数据包后，将数据进行渲染。</p>
<pre><code>// HTTP响应报文一般格式
HTTP/1.1 200 OK
Connection: close
Date: 
Content-Length: 1111
Content-Type: text/html
data..data....data...data
</code></pre>
<p>TODO 补充接受数据的过程</p>
<h4 id="参考链接">参考链接</h4>
<p>计算机网络 自顶向下方法<br>
精通Linux内核网络<br>
https://juejin.cn/post/6970632333397327909<br>
https://docs.microsoft.com/en-us/windows-hardware/drivers/network/network-interface-card-support<br>
https://www.cnblogs.com/f-ck-need-u/p/7623252.html#auto_id_6<br>
https://segmentfault.com/a/1190000008926093<br>
https://segmentfault.com/a/1190000008836467<br>
https://www.erg.abdn.ac.uk/users/gorry/course/lan-pages/nic.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://woxiaosa.github.io/post/hello-gridea/</id>
        <link href="https://woxiaosa.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>