<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Linux进程、线程 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://woxiaosa.github.io//favicon.ico?v=1636269668186">
<link rel="stylesheet" href="https://woxiaosa.github.io//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="Linux中，每个进程必有一个父进程
进程存放在一个双向循环列表中
vfork，不拷贝父进程的页表项，其他和fork一样
在Linux中，线程仅仅被视作一个和其他进程共享某些资源的进程，每个线程dou'you自己的task_struct，看..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://woxiaosa.github.io/">
        <img src="https://woxiaosa.github.io//images/avatar.png?v=1636269668186" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://woxiaosa.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Linux进程、线程</h2>
            <div class="post-date">2021-11-06</div>
            
            <div class="post-content" v-pre>
              <p>Linux中，每个进程必有一个父进程<br>
进程存放在一个双向循环列表中</p>
<p>vfork，不拷贝父进程的页表项，其他和fork一样<br>
在Linux中，线程仅仅被视作一个和其他进程共享某些资源的进程，每个线程dou'you自己的task_struct，看起来就像一个进程</p>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。</p>
<p>内核线程和普通线程区别：mm指针为空，运行在内核空间</p>
<h3 id="定义">定义</h3>
<p>进程是资源分配的最小单位，进程就是处于执行期的程序，但进程还包括了处理器状态、页表、打开的文件描述符等信息。</p>
<p>线程是程序执行的最小单位，在Linux中，线程具有独立的栈、计数器等等，并且Linux内核调度的对象就是线程，而不是进程。Linux并不区分进程与线程，线程仅被视作成和其他进程共享某些资源的进程，这些资源有地址空间、文件描述符等等。</p>
<p>在Linux中，用<code>task_struct</code>存放进程/线程，它以双向链表的形式组织在一起，它包括打开的文件、地址空间、进程的状态、父进程、优先级、pid等信息。</p>
<pre><code class="language-C++">struct task_struct {
    struct thread                _info thread_info;
    unsigned int                 __state;            // 进程状态
    void                          *stack;             // 栈
    int                                 prio;                 // 调度优先级
    struct mm_struct          *mm;               // 地址空间（包含页表
    pid_t                             pid;                  // pid
    struct list_head            children;           // 子进程
    struct files_struct         *files;                // 打开的文件
    struct thread_struct     thread;             // cpu状态（CPU上下文
}
</code></pre>
<h3 id="创建进程">创建进程</h3>
<h4 id="fork">fork()</h4>
<p>在Linux.5.15的代码中，<code>fork()</code>最终是由<code>copy_process</code>实现的，在这个函数中，根据传入的参数，完成对<code>task_struct</code>进程信息的复制，包括栈、进程空间、打开的文件、命名空间、文件系统信息等。</p>
<blockquote>
<p>在Linux-5.15的代码中，fork与clone最终都是由<code>kernel_clone</code>(<code>kernel_clone</code>又调用了<code>copy_process()</code>)函数实现，只是传入的参数不同而已，不同的参数，意味着不同的资源被复制，不同的资源被父子之间共享</p>
</blockquote>
<pre><code class="language-C++">pid_t kernel_clone(struct kernel_clone_args *args)
{
	u64 clone_flags = args-&gt;flags;
    ......
	p = copy_process(NULL, trace, NUMA_NO_NODE, args);
    .....
	pid = get_task_pid(p, PIDTYPE_PID);
	nr = pid_vnr(pid);
    ......
	if (clone_flags &amp; CLONE_VFORK) {
		p-&gt;vfork_done = &amp;vfork;
		init_completion(&amp;vfork);
		get_task_struct(p);
	}
	wake_up_new_task(p);
	put_pid(pid);
	return nr;
}
</code></pre>
<pre><code class="language-C++">static __latent_entropy struct task_struct *copy_process(
					struct pid *pid,
					int trace,
					int node,
					struct kernel_clone_args *args) {
	if (retval)
		goto bad_fork_cleanup_audit;
	retval = copy_semundo(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_security;
	retval = copy_files(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_semundo;
	retval = copy_fs(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_files;
	retval = copy_sighand(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_fs;
	retval = copy_signal(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_sighand;
	retval = copy_mm(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_signal;
	retval = copy_namespaces(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_mm;
	retval = copy_io(clone_flags, p);
	if (retval)
		goto bad_fork_cleanup_namespaces;
	retval = copy_thread(clone_flags, args-&gt;stack, args-&gt;stack_size, p, args-&gt;tls);
	if (retval)
		goto bad_fork_cleanup_io;
}
</code></pre>
<h4 id="vfork">vfork()</h4>
<p>除了不复制地址空间外，<code>vfork()</code>与<code>fork()</code>基本一样，子进程作为一个单独的进程在父进程的地址空间里运行，并且先于父进程执行，在子进程运行期间，父进程被阻塞，直到子进程运行结束。</p>
<h4 id="写时复制">写时复制</h4>
<p>通过<code>fork</code>创建子进程时，地址空间并不复制到子进程中，而是父子进程共用一个地址空间。当父子进程其中的一个要写入数据时，数据才会复制，此时会触发<code>page fault</code>，然后将触发<code>page fault</code>物理页的内容拷贝到一个新物理页中，并在触发进程的页表中，添加该物理页的映射。</p>
<p>这种优化方法，可以避免创建进程时，大量无用地址空间的拷贝。</p>
<h3 id="创建线程">创建线程</h3>
<p>在Linux-5.15中，<code>clone</code>系统调用可以根据传入的参数，有选择的共享父子进程之间的资源，和<code>fork</code>一样，页是通过向<code>kernel_clone()</code>传入参数来实现的。由于进程和线程在实现方面，区别不大，所以暂且把<code>clone</code>当作创建线程的方式。</p>
<h3 id="内核进程线程">内核进程（线程）</h3>
<p>内核线程并没有单独的数据结构，与普通的用户进程相比，只是它指向地址空间的指针<code>mm</code>为空，因为他们只运行在内核空间，不需要切换到用户空间。</p>
<h3 id="进程通信方式">进程通信方式</h3>
<ol>
<li>管道</li>
</ol>
<p>管道是单向的进程通信方式，通常以先进先出的缓冲区来管理数据。</p>
<p>一般是创建长度为2的int数组，然后使用pipe函数进行初始化，第1个是写文件描述符的编号，第0个是读文件描述符的编号。</p>
<p>管道一般有匿名管道和命名管道两种实现方式。</p>
<ul>
<li>匿名管道是通过<code>pipe</code>函数创建的，如果在初始化文件描述符数组后，使用fork来获得一个子进程，那么这两个进程实际上都能拿到读写的端口，一般来说，父子进程要主动的关闭多余的端口，否则容易导致出现错误。可以发现，如果不是不是有着创建-被创建的进程关系，其他进程关系的进程组合，就很难用这种方式创建的管道通信</li>
<li>命名管道是通过<code>mkfifo</code>函数创建的，创建时，会指定一个全局文件名，由这个文件名来指代一个具体的管道，所以只要两个进程用相同的管道命创建管道，就可以进行管道通信。</li>
</ul>
<ol start="2">
<li>消息队列</li>
</ol>
<p>消息队列是内核提供的、唯一一个以消息为数据抽象的通信方式。消息队列是由消息组成的链表，放在内核中。</p>
<ol start="3">
<li>信号量</li>
</ol>
<p>信号量传递的信息比较少，一般用于进程间同步。通常来说，信号量仅有一个共享的、由内核维护的整形计数器、对该计数器的修改需要通过系统调用。</p>
<p>进程通过P、V两个操作来修改信号量。前者试图将信号量减一，如果失败，则会阻塞；V会将信号量加一，并且会唤醒一个因P操作阻塞的进程。</p>
<ol start="4">
<li>共享内存</li>
</ol>
<p>两个进程的通信建立之后，实际上可以不需要内核的参与了，不然会产生一定的性能损失。共享内存的核心思想就是，允许两个进程，在自己的地址空间上，映射相同的物理内存页，从而达到互相通信的目的。</p>
<ol start="5">
<li>套接字通信</li>
</ol>
<p>进程之间，可以通过TCP或者UDP协议进行通信。</p>
<h3 id="线程通信方式">线程通信方式</h3>
<p>利用共享存储空间来通信。</p>
<h3 id="上下文切换">上下文切换</h3>
<p>进程上下文切换对性能的影响更大，因为线程之间共享地址空间，因此TLB（页表缓存）无需刷新。</p>
<blockquote>
<p>上下文包括寄存器、栈，在切换上下文时，TLB要根据情况选择是否刷新，是否切换页表</p>
</blockquote>
<h3 id="linux中的进程线程调度">Linux中的进程/线程调度</h3>
<p>在Linux中，提供了多种类型的调度器<strong>CFS调度器</strong>、<strong>实时调度器</strong>、<strong>截止时间调度器</strong>，不同调度器之间以一种类似于多级队列的方式，被统一调度。</p>
<table>
<thead>
<tr>
<th>调度器</th>
<th>调度策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CFS</td>
<td>SCHED_OTHER</td>
<td>公平的分时调度策略</td>
</tr>
<tr>
<td>CFS</td>
<td>SCHED_BATCH</td>
<td>批处理任务的调度策略（CPU密集型）</td>
</tr>
<tr>
<td>CFS</td>
<td>SCHED_IDLE</td>
<td>后台任务的调度策略（优先级最低）</td>
</tr>
<tr>
<td>RT</td>
<td>SCHED_FIFO</td>
<td>根据实时任务的优先级不同，划分为多个队列，同一队列内按先来先服务进行运行</td>
</tr>
<tr>
<td>RT</td>
<td>SCHED_RR</td>
<td>根据实时任务的优先级不同，划分为多个队列，同一队列内时间片轮转调度算法运行</td>
</tr>
<tr>
<td>DL</td>
<td>SCHED_DEADLINE</td>
<td>最早截止时间优先</td>
</tr>
</tbody>
</table>
<h4 id="cfs">CFS</h4>
<p>从Linux-2.6.23开始，CFS（Complete Fair Scheduler）就成为了Linux的默认调度器。CFS的目的是让OS表现的像拥有一个&quot;完美的多任务处理器&quot;一样。</p>
<blockquote>
<p>与调度相关的信息，被放在了<code>task_struct</code>，一个<code>sched_entity</code>类型的成员变量中</p>
</blockquote>
<p>在Linux中，CFS会根据Nice值来得到任务权重（Nice值越小，权重越大），权重越大的任务，会分得更多的运行时间。</p>
<p><code>run_time_i</code> = <code>sched_perid</code> * <code>weight_i</code> / <code>all_weight_sum</code></p>
<p>其中，<code>sched_perid</code>指的是CPU一个调度周期的时长，<code>all_weight_sum</code>指的是所有带调度任务的权重之和。</p>
<p>同时，CFS算法的一个核心是，为每一个任务维护一个虚拟运行时间<code>vruntime</code>，不同任务的单次调度的运行时长不同，但他们的<code>vruntime</code>增量是相同的，CFS算法每次在选择待调度任务时，就选择一个<code>vruntime</code>最小的任务来进行调度。</p>
<p>CFS算法需要选出<code>vruntime</code>最小的任务，以及插入一个特定<code>vruntime</code>的任务，因此，Linux的CFS调度算法使用红黑树来存储运行队列。红黑树能够在<code>O(1)</code>的时间复杂度内，得到<code>vruntime</code>最小的任务，以<code>O(logN)</code>的时间复杂度完成插入。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://woxiaosa.github.io/post/suo-tiao-jian-bian-liang-xin-hao-liang/">
                  <h3 class="post-title">
                    锁、条件变量、信号量
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
